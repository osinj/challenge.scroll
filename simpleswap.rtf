{\rtf1\ansi\ansicpg1252\cocoartf2639
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red79\green123\blue61;\red26\green26\blue41;\red172\green172\blue193;
\red70\green137\blue204;\red212\green212\blue212;\red167\green197\blue152;\red13\green102\blue149;\red140\green108\blue11;
\red45\green175\blue118;\red31\green133\blue64;\red253\green181\blue13;\red237\green114\blue173;\red14\green86\blue166;
\red194\green126\blue101;}
{\*\expandedcolortbl;;\cssrgb\c37647\c54510\c30588;\cssrgb\c13333\c13725\c21176;\cssrgb\c72941\c73333\c80000;
\cssrgb\c33725\c61176\c83922;\cssrgb\c86275\c86275\c86275;\cssrgb\c70980\c80784\c65882;\cssrgb\c0\c47843\c65098;\cssrgb\c61961\c49412\c3137;
\cssrgb\c19608\c72941\c53725;\cssrgb\c12941\c58039\c31765;\cssrgb\c100000\c75686\c2745;\cssrgb\c95294\c54118\c73333;\cssrgb\c3137\c42353\c70980;
\cssrgb\c80784\c56863\c47059;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 // SPDX-License-Identifier: MIT\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // File: @uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\cf4 \cb1 \strokec4 \
\
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 pragma\cf4 \strokec4  \cf5 \strokec5 solidity\cf4 \strokec4  \cf6 \strokec6 >=\cf7 \strokec7 0.5.0\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 /// @title Callback for IUniswapV3PoolActions#swap\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 /// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 interface IUniswapV3SwapCallback \cf6 \strokec6 \{\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @dev In the implementation you must pay the pool tokens owed for the swap.\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 function\cf4 \strokec4  uniswapV3SwapCallback\cf6 \strokec6 (\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 int256\cf4 \strokec4  amount0Delta\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 int256\cf4 \strokec4  amount1Delta\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3         \cf8 \strokec8 bytes\cf4 \strokec4  \cf9 \strokec9 calldata\cf4 \strokec4  data\cb1 \
\cb3     \cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 \}\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // File: @uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\cf4 \cb1 \strokec4 \
\
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 pragma\cf4 \strokec4  \cf5 \strokec5 solidity\cf4 \strokec4  \cf6 \strokec6 >=\cf7 \strokec7 0.7.5\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 pragma\cf4 \strokec4  abicoder v2\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 /// @title Router token swapping functionality\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 /// @notice Functions for swapping tokens via Uniswap V3\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 interface ISwapRouter \cf5 \strokec5 is\cf4 \strokec4  IUniswapV3SwapCallback \cf6 \strokec6 \{\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 struct\cf4 \strokec4  ExactInputSingleParams \cf6 \strokec6 \{\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  tokenIn\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  tokenOut\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint24\cf4 \strokec4  fee\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  recipient\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  deadline\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountIn\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountOutMinimum\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint160\cf4 \strokec4  sqrtPriceLimitX96\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3     \cf6 \strokec6 \}\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /// @notice Swaps `amountIn` of one token for as much as possible of another token\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @return amountOut The amount of the received token\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 function\cf4 \strokec4  exactInputSingle\cf6 \strokec6 (\cf4 \strokec4 ExactInputSingleParams \cf9 \strokec9 calldata\cf4 \strokec4  params\cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf10 \strokec10 payable\cf4 \strokec4  \cf11 \strokec11 returns\cf4 \strokec4  \cf6 \strokec6 (\cf5 \strokec5 uint256\cf4 \strokec4  amountOut\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 struct\cf4 \strokec4  ExactInputParams \cf6 \strokec6 \{\cf4 \cb1 \strokec4 \
\cb3         \cf8 \strokec8 bytes\cf4 \strokec4  path\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  recipient\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  deadline\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountIn\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountOutMinimum\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3     \cf6 \strokec6 \}\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @return amountOut The amount of the received token\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 function\cf4 \strokec4  exactInput\cf6 \strokec6 (\cf4 \strokec4 ExactInputParams \cf9 \strokec9 calldata\cf4 \strokec4  params\cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf10 \strokec10 payable\cf4 \strokec4  \cf11 \strokec11 returns\cf4 \strokec4  \cf6 \strokec6 (\cf5 \strokec5 uint256\cf4 \strokec4  amountOut\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 struct\cf4 \strokec4  ExactOutputSingleParams \cf6 \strokec6 \{\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  tokenIn\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  tokenOut\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint24\cf4 \strokec4  fee\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  recipient\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  deadline\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountOut\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountInMaximum\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint160\cf4 \strokec4  sqrtPriceLimitX96\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3     \cf6 \strokec6 \}\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /// @notice Swaps as little as possible of one token for `amountOut` of another token\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @return amountIn The amount of the input token\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 function\cf4 \strokec4  exactOutputSingle\cf6 \strokec6 (\cf4 \strokec4 ExactOutputSingleParams \cf9 \strokec9 calldata\cf4 \strokec4  params\cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf10 \strokec10 payable\cf4 \strokec4  \cf11 \strokec11 returns\cf4 \strokec4  \cf6 \strokec6 (\cf5 \strokec5 uint256\cf4 \strokec4  amountIn\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 struct\cf4 \strokec4  ExactOutputParams \cf6 \strokec6 \{\cf4 \cb1 \strokec4 \
\cb3         \cf8 \strokec8 bytes\cf4 \strokec4  path\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  recipient\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  deadline\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountOut\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountInMaximum\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3     \cf6 \strokec6 \}\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @return amountIn The amount of the input token\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 function\cf4 \strokec4  exactOutput\cf6 \strokec6 (\cf4 \strokec4 ExactOutputParams \cf9 \strokec9 calldata\cf4 \strokec4  params\cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf10 \strokec10 payable\cf4 \strokec4  \cf11 \strokec11 returns\cf4 \strokec4  \cf6 \strokec6 (\cf5 \strokec5 uint256\cf4 \strokec4  amountIn\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 \}\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // File: @openzeppelin/contracts/token/ERC20/IERC20.sol\cf4 \cb1 \strokec4 \
\
\
\cf2 \cb3 \strokec2 // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 pragma\cf4 \strokec4  \cf5 \strokec5 solidity\cf4 \strokec4  \cf6 \strokec6 ^\cf7 \strokec7 0.8.20\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 /**\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2  * @dev Interface of the ERC20 standard as defined in the EIP.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2  */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 interface IERC20 \cf6 \strokec6 \{\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /**\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2      * @dev Emitted when `value` tokens are moved from one account (`from`) to\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * another (`to`).\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      *\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * Note that `value` may be zero.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 event\cf4 \strokec4  Transfer\cf6 \strokec6 (\cf5 \strokec5 address\cf4 \strokec4  \cf12 \strokec12 indexed\cf4 \strokec4  from\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 address\cf4 \strokec4  \cf12 \strokec12 indexed\cf4 \strokec4  to\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 uint256\cf4 \strokec4  value\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /**\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2      * @dev Emitted when the allowance of a `spender` for an `owner` is set by\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * a call to \{approve\}. `value` is the new allowance.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 event\cf4 \strokec4  Approval\cf6 \strokec6 (\cf5 \strokec5 address\cf4 \strokec4  \cf12 \strokec12 indexed\cf4 \strokec4  owner\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 address\cf4 \strokec4  \cf12 \strokec12 indexed\cf4 \strokec4  spender\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 uint256\cf4 \strokec4  value\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /**\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2      * @dev Returns the value of tokens in existence.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 function\cf4 \strokec4  totalSupply\cf6 \strokec6 ()\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf10 \strokec10 view\cf4 \strokec4  \cf11 \strokec11 returns\cf4 \strokec4  \cf6 \strokec6 (\cf5 \strokec5 uint256\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /**\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2      * @dev Returns the value of tokens owned by `account`.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 function\cf4 \strokec4  balanceOf\cf6 \strokec6 (\cf5 \strokec5 address\cf4 \strokec4  account\cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf10 \strokec10 view\cf4 \strokec4  \cf11 \strokec11 returns\cf4 \strokec4  \cf6 \strokec6 (\cf5 \strokec5 uint256\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /**\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2      * @dev Moves a `value` amount of tokens from the caller's account to `to`.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      *\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * Returns a boolean value indicating whether the operation succeeded.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      *\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * Emits a \{Transfer\} event.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 function\cf4 \strokec4  transfer\cf6 \strokec6 (\cf5 \strokec5 address\cf4 \strokec4  to\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 uint256\cf4 \strokec4  value\cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf11 \strokec11 returns\cf4 \strokec4  \cf6 \strokec6 (\cf5 \strokec5 bool\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /**\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2      * @dev Returns the remaining number of tokens that `spender` will be\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * allowed to spend on behalf of `owner` through \{transferFrom\}. This is\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * zero by default.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      *\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * This value changes when \{approve\} or \{transferFrom\} are called.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 function\cf4 \strokec4  allowance\cf6 \strokec6 (\cf5 \strokec5 address\cf4 \strokec4  owner\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 address\cf4 \strokec4  spender\cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf10 \strokec10 view\cf4 \strokec4  \cf11 \strokec11 returns\cf4 \strokec4  \cf6 \strokec6 (\cf5 \strokec5 uint256\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /**\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2      * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * caller's tokens.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      *\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * Returns a boolean value indicating whether the operation succeeded.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      *\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * IMPORTANT: Beware that changing an allowance with this method brings the risk\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * that someone may use both the old and the new allowance by unfortunate\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * transaction ordering. One possible solution to mitigate this race\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * condition is to first reduce the spender's allowance to 0 and set the\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * desired value afterwards:\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      *\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * Emits an \{Approval\} event.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 function\cf4 \strokec4  approve\cf6 \strokec6 (\cf5 \strokec5 address\cf4 \strokec4  spender\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 uint256\cf4 \strokec4  value\cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf11 \strokec11 returns\cf4 \strokec4  \cf6 \strokec6 (\cf5 \strokec5 bool\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /**\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2      * @dev Moves a `value` amount of tokens from `from` to `to` using the\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * allowance mechanism. `value` is then deducted from the caller's\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * allowance.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      *\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * Returns a boolean value indicating whether the operation succeeded.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      *\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * Emits a \{Transfer\} event.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 function\cf4 \strokec4  transferFrom\cf6 \strokec6 (\cf5 \strokec5 address\cf4 \strokec4  from\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 address\cf4 \strokec4  to\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 uint256\cf4 \strokec4  value\cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf11 \strokec11 returns\cf4 \strokec4  \cf6 \strokec6 (\cf5 \strokec5 bool\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 \}\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // File: TokenSwap.sol\cf4 \cb1 \strokec4 \
\
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 pragma\cf4 \strokec4  \cf5 \strokec5 solidity\cf4 \strokec4  \cf6 \strokec6 ^\cf7 \strokec7 0.8.24\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3  \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // Importing the necessary interfaces and libraries\cf4 \cb1 \strokec4 \
\
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3  \cb1 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 contract\cf4 \strokec4  SimpleTokenSwap \cf6 \strokec6 \{\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     ISwapRouter \cf10 \strokec10 public\cf4 \strokec4  swapRouter\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 address\cf4 \strokec4  \cf10 \strokec10 public\cf4 \strokec4  WETH\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3  \cb1 \
\cb3     \cf2 \strokec2 // Setting the Uniswap Router address and WETH address in the constructor\cf4 \cb1 \strokec4 \
\cb3     \cf13 \strokec13 constructor\cf6 \strokec6 (\cf5 \strokec5 address\cf4 \strokec4  _swapRouter\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 address\cf4 \strokec4  _WETH\cf6 \strokec6 )\cf4 \strokec4  \cf6 \strokec6 \{\cf4 \cb1 \strokec4 \
\cb3         swapRouter \cf6 \strokec6 =\cf4 \strokec4  ISwapRouter\cf6 \strokec6 (\cf4 \strokec4 _swapRouter\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\cb3         WETH \cf6 \strokec6 =\cf4 \strokec4  _WETH\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3     \cf6 \strokec6 \}\cf4 \cb1 \strokec4 \
\cb3  \cb1 \
\cb3     \cf2 \strokec2 // Create a swap function that takes input and output token addresses,\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // the input amount, the minimum output amount, and the recipient's address\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 function\cf4 \strokec4  swap\cf6 \strokec6 (\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  tokenIn\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  tokenOut\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountIn\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountOutMinimum\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  recipient\cb1 \
\cb3     \cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf6 \strokec6 \{\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 // Transfer the input tokens from the sender to the contract\cf4 \cb1 \strokec4 \
\cb3         \cf8 \strokec8 require\cf6 \strokec6 (\cf4 \strokec4 IERC20\cf6 \strokec6 (\cf4 \strokec4 tokenIn\cf6 \strokec6 ).\cf4 \strokec4 transferFrom\cf6 \strokec6 (\cf8 \strokec8 msg\cf6 \strokec6 .\cf4 \strokec4 sender\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 address\cf6 \strokec6 (\cf14 \strokec14 this\cf6 \strokec6 ),\cf4 \strokec4  amountIn\cf6 \strokec6 ),\cf4 \strokec4  \cf15 \strokec15 "Transfer failed"\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\cb3  \cb1 \
\cb3         \cf2 \strokec2 // Approve the Uniswap router to spend the input tokens\cf4 \cb1 \strokec4 \
\cb3         \cf8 \strokec8 require\cf6 \strokec6 (\cf4 \strokec4 IERC20\cf6 \strokec6 (\cf4 \strokec4 tokenIn\cf6 \strokec6 ).\cf4 \strokec4 approve\cf6 \strokec6 (\cf5 \strokec5 address\cf6 \strokec6 (\cf4 \strokec4 swapRouter\cf6 \strokec6 ),\cf4 \strokec4  amountIn\cf6 \strokec6 ),\cf4 \strokec4  \cf15 \strokec15 "Approval failed"\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\cb3  \cb1 \
\cb3         \cf2 \strokec2 // Create the swap parameters\cf4 \cb1 \strokec4 \
\cb3         ISwapRouter\cf6 \strokec6 .\cf4 \strokec4 ExactInputSingleParams \cf9 \strokec9 memory\cf4 \strokec4  params \cf6 \strokec6 =\cf4 \strokec4  ISwapRouter\cf6 \strokec6 .\cf4 \strokec4 ExactInputSingleParams\cf6 \strokec6 (\{\cf4 \cb1 \strokec4 \
\cb3             tokenIn\cf6 \strokec6 :\cf4 \strokec4  tokenIn\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3             tokenOut\cf6 \strokec6 :\cf4 \strokec4  tokenOut\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3             fee\cf6 \strokec6 :\cf4 \strokec4  \cf7 \strokec7 3000\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 // Using a 0.3% fee tier\cf4 \cb1 \strokec4 \
\cb3             recipient\cf6 \strokec6 :\cf4 \strokec4  recipient\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3             deadline\cf6 \strokec6 :\cf4 \strokec4  \cf8 \strokec8 block\cf6 \strokec6 .\cf4 \strokec4 timestamp\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3             amountIn\cf6 \strokec6 :\cf4 \strokec4  amountIn\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3             amountOutMinimum\cf6 \strokec6 :\cf4 \strokec4  amountOutMinimum\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3             sqrtPriceLimitX96\cf6 \strokec6 :\cf4 \strokec4  \cf7 \strokec7 0\cf4 \cb1 \strokec4 \
\cb3         \cf6 \strokec6 \});\cf4 \cb1 \strokec4 \
\cb3  \cb1 \
\cb3         \cf2 \strokec2 // Call the Uniswap router's exactInputSingle function to execute the swap\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountOut \cf6 \strokec6 =\cf4 \strokec4  swapRouter\cf6 \strokec6 .\cf4 \strokec4 exactInputSingle\cf6 \strokec6 (\cf4 \strokec4 params\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\cb3  \cb1 \
\cb3         \cf8 \strokec8 require\cf6 \strokec6 (\cf4 \strokec4 amountOut \cf6 \strokec6 >=\cf4 \strokec4  amountOutMinimum\cf6 \strokec6 ,\cf4 \strokec4  \cf15 \strokec15 "Insufficient output amount"\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\cb3     \cf6 \strokec6 \}\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 \}\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // SPDX-License-Identifier: MIT\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // File: @uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\cf4 \cb1 \strokec4 \
\
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 pragma\cf4 \strokec4  \cf5 \strokec5 solidity\cf4 \strokec4  \cf6 \strokec6 >=\cf7 \strokec7 0.5.0\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 /// @title Callback for IUniswapV3PoolActions#swap\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 /// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 interface IUniswapV3SwapCallback \cf6 \strokec6 \{\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @dev In the implementation you must pay the pool tokens owed for the swap.\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 function\cf4 \strokec4  uniswapV3SwapCallback\cf6 \strokec6 (\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 int256\cf4 \strokec4  amount0Delta\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 int256\cf4 \strokec4  amount1Delta\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3         \cf8 \strokec8 bytes\cf4 \strokec4  \cf9 \strokec9 calldata\cf4 \strokec4  data\cb1 \
\cb3     \cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 \}\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // File: @uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\cf4 \cb1 \strokec4 \
\
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 pragma\cf4 \strokec4  \cf5 \strokec5 solidity\cf4 \strokec4  \cf6 \strokec6 >=\cf7 \strokec7 0.7.5\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 pragma\cf4 \strokec4  abicoder v2\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 /// @title Router token swapping functionality\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 /// @notice Functions for swapping tokens via Uniswap V3\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 interface ISwapRouter \cf5 \strokec5 is\cf4 \strokec4  IUniswapV3SwapCallback \cf6 \strokec6 \{\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 struct\cf4 \strokec4  ExactInputSingleParams \cf6 \strokec6 \{\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  tokenIn\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  tokenOut\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint24\cf4 \strokec4  fee\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  recipient\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  deadline\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountIn\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountOutMinimum\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint160\cf4 \strokec4  sqrtPriceLimitX96\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3     \cf6 \strokec6 \}\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /// @notice Swaps `amountIn` of one token for as much as possible of another token\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @return amountOut The amount of the received token\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 function\cf4 \strokec4  exactInputSingle\cf6 \strokec6 (\cf4 \strokec4 ExactInputSingleParams \cf9 \strokec9 calldata\cf4 \strokec4  params\cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf10 \strokec10 payable\cf4 \strokec4  \cf11 \strokec11 returns\cf4 \strokec4  \cf6 \strokec6 (\cf5 \strokec5 uint256\cf4 \strokec4  amountOut\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 struct\cf4 \strokec4  ExactInputParams \cf6 \strokec6 \{\cf4 \cb1 \strokec4 \
\cb3         \cf8 \strokec8 bytes\cf4 \strokec4  path\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  recipient\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  deadline\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountIn\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountOutMinimum\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3     \cf6 \strokec6 \}\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @return amountOut The amount of the received token\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 function\cf4 \strokec4  exactInput\cf6 \strokec6 (\cf4 \strokec4 ExactInputParams \cf9 \strokec9 calldata\cf4 \strokec4  params\cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf10 \strokec10 payable\cf4 \strokec4  \cf11 \strokec11 returns\cf4 \strokec4  \cf6 \strokec6 (\cf5 \strokec5 uint256\cf4 \strokec4  amountOut\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 struct\cf4 \strokec4  ExactOutputSingleParams \cf6 \strokec6 \{\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  tokenIn\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  tokenOut\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint24\cf4 \strokec4  fee\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  recipient\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  deadline\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountOut\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountInMaximum\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint160\cf4 \strokec4  sqrtPriceLimitX96\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3     \cf6 \strokec6 \}\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /// @notice Swaps as little as possible of one token for `amountOut` of another token\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @return amountIn The amount of the input token\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 function\cf4 \strokec4  exactOutputSingle\cf6 \strokec6 (\cf4 \strokec4 ExactOutputSingleParams \cf9 \strokec9 calldata\cf4 \strokec4  params\cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf10 \strokec10 payable\cf4 \strokec4  \cf11 \strokec11 returns\cf4 \strokec4  \cf6 \strokec6 (\cf5 \strokec5 uint256\cf4 \strokec4  amountIn\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 struct\cf4 \strokec4  ExactOutputParams \cf6 \strokec6 \{\cf4 \cb1 \strokec4 \
\cb3         \cf8 \strokec8 bytes\cf4 \strokec4  path\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  recipient\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  deadline\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountOut\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountInMaximum\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3     \cf6 \strokec6 \}\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /// @return amountIn The amount of the input token\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 function\cf4 \strokec4  exactOutput\cf6 \strokec6 (\cf4 \strokec4 ExactOutputParams \cf9 \strokec9 calldata\cf4 \strokec4  params\cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf10 \strokec10 payable\cf4 \strokec4  \cf11 \strokec11 returns\cf4 \strokec4  \cf6 \strokec6 (\cf5 \strokec5 uint256\cf4 \strokec4  amountIn\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 \}\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // File: @openzeppelin/contracts/token/ERC20/IERC20.sol\cf4 \cb1 \strokec4 \
\
\
\cf2 \cb3 \strokec2 // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 pragma\cf4 \strokec4  \cf5 \strokec5 solidity\cf4 \strokec4  \cf6 \strokec6 ^\cf7 \strokec7 0.8.20\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 /**\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2  * @dev Interface of the ERC20 standard as defined in the EIP.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2  */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 interface IERC20 \cf6 \strokec6 \{\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 /**\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2      * @dev Emitted when `value` tokens are moved from one account (`from`) to\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * another (`to`).\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      *\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * Note that `value` may be zero.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 event\cf4 \strokec4  Transfer\cf6 \strokec6 (\cf5 \strokec5 address\cf4 \strokec4  \cf12 \strokec12 indexed\cf4 \strokec4  from\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 address\cf4 \strokec4  \cf12 \strokec12 indexed\cf4 \strokec4  to\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 uint256\cf4 \strokec4  value\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /**\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2      * @dev Emitted when the allowance of a `spender` for an `owner` is set by\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * a call to \{approve\}. `value` is the new allowance.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 event\cf4 \strokec4  Approval\cf6 \strokec6 (\cf5 \strokec5 address\cf4 \strokec4  \cf12 \strokec12 indexed\cf4 \strokec4  owner\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 address\cf4 \strokec4  \cf12 \strokec12 indexed\cf4 \strokec4  spender\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 uint256\cf4 \strokec4  value\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /**\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2      * @dev Returns the value of tokens in existence.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 function\cf4 \strokec4  totalSupply\cf6 \strokec6 ()\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf10 \strokec10 view\cf4 \strokec4  \cf11 \strokec11 returns\cf4 \strokec4  \cf6 \strokec6 (\cf5 \strokec5 uint256\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /**\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2      * @dev Returns the value of tokens owned by `account`.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 function\cf4 \strokec4  balanceOf\cf6 \strokec6 (\cf5 \strokec5 address\cf4 \strokec4  account\cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf10 \strokec10 view\cf4 \strokec4  \cf11 \strokec11 returns\cf4 \strokec4  \cf6 \strokec6 (\cf5 \strokec5 uint256\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /**\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2      * @dev Moves a `value` amount of tokens from the caller's account to `to`.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      *\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * Returns a boolean value indicating whether the operation succeeded.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      *\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * Emits a \{Transfer\} event.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 function\cf4 \strokec4  transfer\cf6 \strokec6 (\cf5 \strokec5 address\cf4 \strokec4  to\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 uint256\cf4 \strokec4  value\cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf11 \strokec11 returns\cf4 \strokec4  \cf6 \strokec6 (\cf5 \strokec5 bool\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /**\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2      * @dev Returns the remaining number of tokens that `spender` will be\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * allowed to spend on behalf of `owner` through \{transferFrom\}. This is\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * zero by default.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      *\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * This value changes when \{approve\} or \{transferFrom\} are called.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 function\cf4 \strokec4  allowance\cf6 \strokec6 (\cf5 \strokec5 address\cf4 \strokec4  owner\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 address\cf4 \strokec4  spender\cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf10 \strokec10 view\cf4 \strokec4  \cf11 \strokec11 returns\cf4 \strokec4  \cf6 \strokec6 (\cf5 \strokec5 uint256\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /**\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2      * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * caller's tokens.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      *\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * Returns a boolean value indicating whether the operation succeeded.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      *\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * IMPORTANT: Beware that changing an allowance with this method brings the risk\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * that someone may use both the old and the new allowance by unfortunate\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * transaction ordering. One possible solution to mitigate this race\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * condition is to first reduce the spender's allowance to 0 and set the\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * desired value afterwards:\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      *\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * Emits an \{Approval\} event.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 function\cf4 \strokec4  approve\cf6 \strokec6 (\cf5 \strokec5 address\cf4 \strokec4  spender\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 uint256\cf4 \strokec4  value\cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf11 \strokec11 returns\cf4 \strokec4  \cf6 \strokec6 (\cf5 \strokec5 bool\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 /**\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2      * @dev Moves a `value` amount of tokens from `from` to `to` using the\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * allowance mechanism. `value` is then deducted from the caller's\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * allowance.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      *\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * Returns a boolean value indicating whether the operation succeeded.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      *\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      * Emits a \{Transfer\} event.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2      */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 function\cf4 \strokec4  transferFrom\cf6 \strokec6 (\cf5 \strokec5 address\cf4 \strokec4  from\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 address\cf4 \strokec4  to\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 uint256\cf4 \strokec4  value\cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf11 \strokec11 returns\cf4 \strokec4  \cf6 \strokec6 (\cf5 \strokec5 bool\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 \}\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // File: TokenSwap.sol\cf4 \cb1 \strokec4 \
\
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 pragma\cf4 \strokec4  \cf5 \strokec5 solidity\cf4 \strokec4  \cf6 \strokec6 ^\cf7 \strokec7 0.8.24\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3  \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // Importing the necessary interfaces and libraries\cf4 \cb1 \strokec4 \
\
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3  \cb1 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 contract\cf4 \strokec4  SimpleTokenSwap \cf6 \strokec6 \{\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     ISwapRouter \cf10 \strokec10 public\cf4 \strokec4  swapRouter\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 address\cf4 \strokec4  \cf10 \strokec10 public\cf4 \strokec4  WETH\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3  \cb1 \
\cb3     \cf2 \strokec2 // Setting the Uniswap Router address and WETH address in the constructor\cf4 \cb1 \strokec4 \
\cb3     \cf13 \strokec13 constructor\cf6 \strokec6 (\cf5 \strokec5 address\cf4 \strokec4  _swapRouter\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 address\cf4 \strokec4  _WETH\cf6 \strokec6 )\cf4 \strokec4  \cf6 \strokec6 \{\cf4 \cb1 \strokec4 \
\cb3         swapRouter \cf6 \strokec6 =\cf4 \strokec4  ISwapRouter\cf6 \strokec6 (\cf4 \strokec4 _swapRouter\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\cb3         WETH \cf6 \strokec6 =\cf4 \strokec4  _WETH\cf6 \strokec6 ;\cf4 \cb1 \strokec4 \
\cb3     \cf6 \strokec6 \}\cf4 \cb1 \strokec4 \
\cb3  \cb1 \
\cb3     \cf2 \strokec2 // Create a swap function that takes input and output token addresses,\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // the input amount, the minimum output amount, and the recipient's address\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 function\cf4 \strokec4  swap\cf6 \strokec6 (\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  tokenIn\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  tokenOut\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountIn\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountOutMinimum\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 address\cf4 \strokec4  recipient\cb1 \
\cb3     \cf6 \strokec6 )\cf4 \strokec4  \cf10 \strokec10 external\cf4 \strokec4  \cf6 \strokec6 \{\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 // Transfer the input tokens from the sender to the contract\cf4 \cb1 \strokec4 \
\cb3         \cf8 \strokec8 require\cf6 \strokec6 (\cf4 \strokec4 IERC20\cf6 \strokec6 (\cf4 \strokec4 tokenIn\cf6 \strokec6 ).\cf4 \strokec4 transferFrom\cf6 \strokec6 (\cf8 \strokec8 msg\cf6 \strokec6 .\cf4 \strokec4 sender\cf6 \strokec6 ,\cf4 \strokec4  \cf5 \strokec5 address\cf6 \strokec6 (\cf14 \strokec14 this\cf6 \strokec6 ),\cf4 \strokec4  amountIn\cf6 \strokec6 ),\cf4 \strokec4  \cf15 \strokec15 "Transfer failed"\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\cb3  \cb1 \
\cb3         \cf2 \strokec2 // Approve the Uniswap router to spend the input tokens\cf4 \cb1 \strokec4 \
\cb3         \cf8 \strokec8 require\cf6 \strokec6 (\cf4 \strokec4 IERC20\cf6 \strokec6 (\cf4 \strokec4 tokenIn\cf6 \strokec6 ).\cf4 \strokec4 approve\cf6 \strokec6 (\cf5 \strokec5 address\cf6 \strokec6 (\cf4 \strokec4 swapRouter\cf6 \strokec6 ),\cf4 \strokec4  amountIn\cf6 \strokec6 ),\cf4 \strokec4  \cf15 \strokec15 "Approval failed"\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\cb3  \cb1 \
\cb3         \cf2 \strokec2 // Create the swap parameters\cf4 \cb1 \strokec4 \
\cb3         ISwapRouter\cf6 \strokec6 .\cf4 \strokec4 ExactInputSingleParams \cf9 \strokec9 memory\cf4 \strokec4  params \cf6 \strokec6 =\cf4 \strokec4  ISwapRouter\cf6 \strokec6 .\cf4 \strokec4 ExactInputSingleParams\cf6 \strokec6 (\{\cf4 \cb1 \strokec4 \
\cb3             tokenIn\cf6 \strokec6 :\cf4 \strokec4  tokenIn\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3             tokenOut\cf6 \strokec6 :\cf4 \strokec4  tokenOut\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3             fee\cf6 \strokec6 :\cf4 \strokec4  \cf7 \strokec7 3000\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 // Using a 0.3% fee tier\cf4 \cb1 \strokec4 \
\cb3             recipient\cf6 \strokec6 :\cf4 \strokec4  recipient\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3             deadline\cf6 \strokec6 :\cf4 \strokec4  \cf8 \strokec8 block\cf6 \strokec6 .\cf4 \strokec4 timestamp\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3             amountIn\cf6 \strokec6 :\cf4 \strokec4  amountIn\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3             amountOutMinimum\cf6 \strokec6 :\cf4 \strokec4  amountOutMinimum\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3             sqrtPriceLimitX96\cf6 \strokec6 :\cf4 \strokec4  \cf7 \strokec7 0\cf4 \cb1 \strokec4 \
\cb3         \cf6 \strokec6 \});\cf4 \cb1 \strokec4 \
\cb3  \cb1 \
\cb3         \cf2 \strokec2 // Call the Uniswap router's exactInputSingle function to execute the swap\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 uint256\cf4 \strokec4  amountOut \cf6 \strokec6 =\cf4 \strokec4  swapRouter\cf6 \strokec6 .\cf4 \strokec4 exactInputSingle\cf6 \strokec6 (\cf4 \strokec4 params\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\cb3  \cb1 \
\cb3         \cf8 \strokec8 require\cf6 \strokec6 (\cf4 \strokec4 amountOut \cf6 \strokec6 >=\cf4 \strokec4  amountOutMinimum\cf6 \strokec6 ,\cf4 \strokec4  \cf15 \strokec15 "Insufficient output amount"\cf6 \strokec6 );\cf4 \cb1 \strokec4 \
\cb3     \cf6 \strokec6 \}\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 \}\cf4 \cb1 \strokec4 \
}